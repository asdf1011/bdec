## vim:set syntax=mako:

## Create the C 'type' of each protocol entry
<%!
    from bdec.choice import Choice
    from bdec.field import Field
    from bdec.sequence import Sequence
    from bdec.sequenceof import SequenceOf
%>

<%def name="c_define(entry)" >
  %if isinstance(entry, Sequence):
${settings.ctype(entry)}
{
  %for i, child in enumerate(entry.children):
    %if not child.is_hidden():
    ${settings.ctype(child)} ${var_name(i, entry.children)};
    %endif
  %endfor
  %if entry.value is not None:
    int value;
  %endif
};
  %elif isinstance(entry, Field):
typedef ${settings.ctype(entry)} ${entry.name |typename};
  %elif isinstance(entry, Choice):
${settings.ctype(entry)}
{
    %for i, child in enumerate(entry.children):
    ${settings.ctype(child)}* ${var_name(i, entry.children)};
    %endfor
};
  %elif isinstance(entry, SequenceOf):
${settings.ctype(entry)}
{
    ${settings.ctype(entry.children[0])}* items;
    unsigned int count;
};
  %else:
#error Unsupported entry ${entry}
  %endif
</%def>

<%def name="define(entry)" >
    %for e in iter_inner_entries(entry):
      %if not isinstance(e, Field):
${c_define(e)}
      %endif
    %endfor
</%def>

<%def name="decode_name(entry)">
${'decode ' + esc_name(iter_entries().index(entry), iter_entries())|function}
</%def>

<%def name="print_name(entry)">
${'print xml ' + esc_name(iter_entries().index(entry), iter_entries())|function}
</%def>

<%def name="var_name(i, other_vars)">
${esc_name(i, other_vars)|variable}
</%def>

<%def name="free_name(entry)">
${'free ' + esc_name(iter_entries().index(entry), iter_entries())|function}
</%def>
